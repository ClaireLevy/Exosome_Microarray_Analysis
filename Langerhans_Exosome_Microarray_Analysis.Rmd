---
title: 'Exosome Microarray Analysis: Langerhans cells only'
author: "Claire Levy"
date: "January 18, 2017"
output: github_document
---


## Experiment overview

Experiments were done on two cells types: Langerhans cells and vaginal epithelial cells.

Langerhans cells from 3 donors were exposed to HIV, Sendai virus or no virus and each of those were exposed to the following:

* Exosomes
* Seminal supernatant
* Liposomes
* Media control

## The following analysis is only for Langerhans cells

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(dplyr)
library(lumi)
library(limma)
library(pander)
library(stringr)
library(ggplot2)
library(reshape2)

```

```{r load lumibatch data and subset , cache = TRUE}

#note that the sampleNames are NOT syntactically valid, here (they have "-")
lumibatch<-lumiR(fileName = "..\\raw_data\\FinalReport.txt",
            detectionTh = 0.05,
            annotationColumn=c('ENTREZ_GENE_ID','ACCESSION', 'SYMBOL', 'PROBE_SEQUENCE', 'PROBE_START', 'CHROMOSOME', 'PROBE_CHR_ORIENTATION', 'PROBE_COORDINATES', 'DEFINITION'))

#read in pData
pData <- read.table("..\\raw_data\\SampleInformation.txt", header = TRUE)

#make names valid in pData
corrected_pData <- pData %>%
  mutate(ArrayName = str_replace(ArrayName,"-","_"))%>%
  mutate(Donor = str_replace(Donor, "-","_"))

#make the rownames of pData the sample as the ArrayName
row.names(corrected_pData)<-corrected_pData$ArrayName


#make names valid in lumibatch
sampleNames(lumibatch)<- unique(corrected_pData$ArrayName)

#put pData into an adf
adf<-AnnotatedDataFrame(data=corrected_pData)


valid_lumibatch<-new("LumiBatch",
                     assayData = assayData(lumibatch),
                     phenoData = adf,
                     detection = detection(lumibatch),
                     controlData = controlData(lumibatch),
                     featureData = featureData(lumibatch))

#subset lumibatch for just the HVE cells
LC_lumibatch<-valid_lumibatch[,valid_lumibatch$CellType == "LC"]
```


Plots of non-normalized data

```{r density}

density(LC_lumibatch)
```

```{r non-norm}
dimensional_data <- plotMDS(LC_lumibatch)#make the plot, it invisibly returns a large object that has the actual dimensions data in matrices called x and y (one for each dimension)

#make a data frame where
d <- data.frame(Dim1 = dimensional_data$x, #Dim1 is a column containing the values from the x matrix
               Dim2 = dimensional_data$y, #Dim2 is a column containing the values from the y matrix
               ArrayName = names(dimensional_data$x))#SampleID is a column that holds the column names from the x matrix, which happen to be the microarray wells.

d <- as_data_frame(merge(d, pData(LC_lumibatch)), by = "ArrayName")
```

```{r non norm MSD plot}

ggplot(d, aes(x = Dim1, y = Dim2))+
  geom_point(aes(color = Treatment, shape = Virus))

ggplot(d, aes(x = Dim1, y = Dim2))+
  geom_point(aes(color = Treatment, shape = Virus))+
  facet_wrap(~Donor)
```

```{r non norm boxplot}

boxplot(LC_lumibatch)
```

```{r background correct transform normalize, results = 'hide'}

		#the data we got from the core had no background correction (I don't think it did anyway...) so I will do it here.
B_LC_lumibatch<-lumiB(LC_lumibatch, method = "bgAdjust")


# VST TRANSFORMATION 
#"Stabilizing the expression variance based on
#the bead level expression variance and mean relations"

TB_LC_lumibatch <-lumiT (B_LC_lumibatch, method = 'vst')
#can do this to look at a plot. plotting doesn't work if I do method = "log2"
# plotVST(TB_LC_lumibatch)

#quantile normalization
NTB_LC_lumibatch<-lumiN(TB_LC_lumibatch,method="quantile")

#QC
QNTB_LC_lumibatch<-lumiQ(NTB_LC_lumibatch)
```


```{r norm density}

density(QNTB_LC_lumibatch)
```

```{r norm MDS}

norm_dimensional_data <- plotMDS(QNTB_LC_lumibatch)#make the plot, it invisibly returns a large object that has the actual dimensions data in matrices called x and y (one for each dimension)

#make a data frame where
normd <- data.frame(Dim1 = norm_dimensional_data$x, #Dim1 is a column containing the values from the x matrix
               Dim2 = norm_dimensional_data$y, #Dim2 is a column containing the values from the y matrix
               ArrayName = names(norm_dimensional_data$x))#SampleID is a column that holds the column names from the x matrix, which happen to be the microarray wells.

normd <- as_data_frame(merge(normd, pData(QNTB_LC_lumibatch)), by = "ArrayName")



ggplot(normd, aes(x=Dim1, y = Dim2))+
  geom_point(aes(shape = Virus, color = Treatment))


ggplot(normd, aes(x=Dim1, y = Dim2))+
  geom_point(aes(shape = Virus, color = Treatment))+
  facet_wrap(~Donor)


```

```{r normed boxplot}
boxplot(QNTB_LC_lumibatch)
```


## Non-specific filtering

Limma suggests to keep probes that are expressed above background on at least n arrays where n is smallest number of replicates assigned to any of the treatment combinations.

 We have 3 donors x 3 viruses x 4 Treatments so I will keep probes with detection levels above background in at least 3 samples.
 
```{r ns filtering}
 #this is how the detection filtering works:
#Mark the detection pvalues (there is one per probe per sample) with a 1 if <0.05 or a 0 if >0.05
# using (detection(QNTB.complete.RAW.lumi)<0.05)

#add up the 0's and 1's across each row (i.e. for all the samples)
#using rowSums

#now you have the number of detection p values <0.05 for each probe
#for all the samples (max possible = total samples)

#now tell me which probes have a rowSum of >=3 (probes will be marked as TRUE
# or false if they do or do not have >=3 rowSum)

LC_detectedProbes <- rowSums(detection(QNTB_LC_lumibatch)<0.05)>= 3

#now extract just those probes that are TRUE from the lumibatch

LC_expressedProbes_lumibatch <-QNTB_LC_lumibatch[LC_detectedProbes,]
```


Number of probes in data set before filtering:

```{r probes before}
dims(QNTB_LC_lumibatch)
```

Number of probes in data set after filtering:


```{r probes after}
dims(LC_expressedProbes_lumibatch)
```

```{r targets and design}

targets <-pData(valid_lumibatch)%>%
  filter(CellType == "LC")%>%
  select(Donor,Virus, Treatment)

Donor <-factor(targets$Donor)

#I'm going to make a vector called "Condition" that is a combination of the Virus and exosome Treatment factors
Condition <-factor(paste(targets$Virus, targets$Treatment, sep = "."))




#When I have ~0 for the intercept, each coeff represents the avg of the samples at each level of Treatment and Donor. If I had used ~1 instead, the intercept would represent the avg of the samples for Media and the next coeff would represent the increase in the average of LowExosomes OVER Media.

HVE_design <-model.matrix(~0+Treatment+Donor)
```